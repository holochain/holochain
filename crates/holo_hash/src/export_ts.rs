//! Helper types and [`ts_rs::TS`] implementations for converting hash types
//! into a form that can be exported to TypeScript for the JavaScript client.
//!
//! In the JavaScript client, all specific hash types are aliases to a 'base'
//! HoloHash type, which is just a Uint8Array. Likewise, all the specific
//! base64-encoded hash types are aliases to a HoloHashB64 type which is just
//! a string. This is something that ts-rs can't infer from the corresponding
//! Rust types and their serde implementations, because those implementations
//! are custom rather than simple proc macros.

#[cfg(feature = "encoding")]
use crate::HoloHashB64;
use crate::{HashType, HoloHash, HoloHashResult};
use std::path::PathBuf;
use ts_rs::TS;

// RAW HASH TYPES

/// The base hash type in TS definitions is `HoloHash`; all concrete types
/// are just aliases of it.
pub(crate) const BASE_HASH_NAME: &str = "HoloHash";

/// A hash type used for exporting the base `HoloHash` to TypeScript.
/// This is mostly here to satisfy ts-rs' requirement that a type's generic
/// parameter(s) be filled in with _something_ for its `WithoutGenerics` prop.
#[derive(Copy, Clone, std::fmt::Debug, std::hash::Hash, PartialEq, Eq, PartialOrd, Ord)]
pub struct BaseHashType;

impl HashType for BaseHashType {
    fn get_prefix(self) -> &'static [u8] {
        unimplemented!("This hash type should not be used outside of exporting to TypeScript")
    }

    fn try_from_prefix(_: &[u8]) -> HoloHashResult<Self> {
        unimplemented!("This hash type should not be used outside of exporting to TypeScript")
    }

    fn hash_name(self) -> &'static str {
        unimplemented!("This hash type should not be used outside of exporting to TypeScript")
    }

    fn static_hash_name() -> &'static str {
        BASE_HASH_NAME
    }

    fn is_base() -> bool {
        true
    }
}

impl TS for BaseHashType {
    type WithoutGenerics = Self;
    type OptionInnerType = Self;

    fn name() -> String {
        "".into()
    }

    fn inline() -> String {
        "".into()
    }

    fn inline_flattened() -> String {
        Self::inline()
    }

    fn decl() -> String {
        "".into()
    }

    fn decl_concrete() -> String {
        Self::decl()
    }
}

impl<T: HashType> TS for HoloHash<T> {
    type WithoutGenerics = HoloHash<BaseHashType>;
    type OptionInnerType = Self;

    fn name() -> String {
        T::static_hash_name().into()
    }

    fn inline() -> String {
        // The base HoloHash is a Uint8Array, whereas all specific hash types
        // are aliases to HoloHash.
        match T::is_base() {
            true => "Uint8Array".into(),
            false => BASE_HASH_NAME.into(),
        }
    }

    fn inline_flattened() -> String {
        Self::inline()
    }

    fn decl() -> String {
        format!("type {} = {};", Self::name(), Self::inline()).into()
    }

    fn decl_concrete() -> String {
        Self::decl()
    }

    // Not used -- only used to make ts-rs be quiet; otherwise it fails with
    // an "Error: this type cannot be exported". I suspect this is an upstream
    // bug but am not interested in fixing it.
    fn output_path() -> Option<PathBuf> {
        let mut path = PathBuf::new();
        path.push(".");
        Some(path)
    }

    // Ditto.
    fn default_output_path() -> Option<PathBuf> {
        let mut path = PathBuf::new();
        path.push(".");
        Some(path)
    }
}

/// The base type for all hashes.
pub type BaseHoloHash = HoloHash<BaseHashType>;

// BASE64-ENCODED HASH TYPES

#[cfg(feature = "encoding")]
impl<T: HashType> TS for HoloHashB64<T> {
    type WithoutGenerics = HoloHashB64<BaseHashType>;
    type OptionInnerType = Self;

    fn name() -> String {
        format!("{}B64", T::static_hash_name()).into()
    }

    fn inline() -> String {
        match T::is_base() {
            true => "string".into(),
            false => format!("{}B64", BASE_HASH_NAME).into(),
        }
    }

    fn inline_flattened() -> String {
        Self::inline()
    }

    fn decl() -> String {
        format!("type {} = {};", Self::name(), Self::inline()).into()
    }

    fn decl_concrete() -> String {
        Self::decl()
    }

    fn output_path() -> Option<PathBuf> {
        let mut path = PathBuf::new();
        path.push(".");
        Some(path)
    }

    fn default_output_path() -> Option<PathBuf> {
        let mut path = PathBuf::new();
        path.push(".");
        Some(path)
    }
}

/// The base type for all Base64-encoded hashes.
#[cfg(feature = "encoding")]
pub type BaseHoloHashB64 = HoloHashB64<BaseHashType>;

#[cfg(test)]
mod tests {
    use super::*;

    // ts-rs produces a little bit of boilerplate when exporting.
    // Strip it so we can focus on the important bits.
    fn strip_extras(output: String) -> String {
        output.replace("// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n", "").trim().to_string()
    }

    #[test]
    fn base_holo_hash_is_byte_array() {
        let result = BaseHoloHash::export_to_string();
        assert!(result.is_ok());
        let output = strip_extras(result.unwrap());
        assert_eq!(output, "export type HoloHash = Uint8Array;".to_string());
    }

    macro_rules! test_specific_hash {
        ($hash_type: ident) => {
            let result = $hash_type::export_to_string();
            assert!(result.is_ok());
            let output = strip_extras(result.unwrap());
            assert_eq!(
                output,
                format!("export type {} = HoloHash;", stringify!($hash_type)).to_string()
            );
        };
    }

    #[test]
    fn specific_holo_hashes_are_aliases_to_base_holo_hash() {
        use crate::aliases::*;
        test_specific_hash!(AgentPubKey);
        test_specific_hash!(DnaHash);
        test_specific_hash!(DhtOpHash);
        test_specific_hash!(EntryHash);
        test_specific_hash!(ActionHash);
        test_specific_hash!(NetIdHash);
        test_specific_hash!(WasmHash);
        test_specific_hash!(WarrantHash);
        test_specific_hash!(ExternalHash);
        test_specific_hash!(AnyDhtHash);
        test_specific_hash!(AnyLinkableHash);
    }

    #[test]
    #[cfg(feature = "encoding")]
    fn base_holo_hash_b64_is_string() {
        let result = BaseHoloHashB64::export_to_string();
        assert!(result.is_ok());
        let output = strip_extras(result.unwrap());
        assert_eq!(output, "export type HoloHashB64 = string;".to_string());
    }

    #[cfg(feature = "encoding")]
    macro_rules! test_specific_b64_hash {
        ($hash_type: ident) => {
            use crate::$hash_type;
            let result = $hash_type::export_to_string();
            assert!(result.is_ok());
            let output = strip_extras(result.unwrap());
            assert_eq!(
                output,
                format!("export type {} = HoloHashB64;", stringify!($hash_type)).to_string()
            );
        };
    }

    #[test]
    #[cfg(feature = "encoding")]
    fn specific_b64_hashes_are_aliases_to_base_holo_hash_b64() {
        test_specific_b64_hash!(AgentPubKeyB64);
        test_specific_b64_hash!(DnaHashB64);
        test_specific_b64_hash!(DhtOpHashB64);
        test_specific_b64_hash!(EntryHashB64);
        test_specific_b64_hash!(ActionHashB64);
        test_specific_b64_hash!(NetIdHashB64);
        test_specific_b64_hash!(WasmHashB64);
        test_specific_b64_hash!(WarrantHashB64);
        test_specific_b64_hash!(ExternalHashB64);
        test_specific_b64_hash!(AnyDhtHashB64);
        test_specific_b64_hash!(AnyLinkableHashB64);
    }
}
