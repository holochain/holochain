use std::env::args;
use std::fs::write;
use std::path::PathBuf;
#[allow(unused_imports)]
use ts_rs::TS;

#[allow(dead_code)]
const TS_RS_PREAMBLE_STR: &str = "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n";
const CUSTOM_PREAMBLE_STR: &str = "// This file was generated by [`export_ts` from the Holochain project](https://github.com/holochain/holochain/tree/main/crates/export_ts). Do not edit this file manually.\n\n";

macro_rules! fill_and_save_buffer {
    ($buffer_name: ident, $path: expr, $file_name: expr, $code: block) => {
        // TODO: remove this override once future usage starts writing to
        // a buffer.
        #[allow(unused_mut)]
        let mut $buffer_name = String::new();
        $buffer_name.push_str(CUSTOM_PREAMBLE_STR);
        let file_path = $path.join($file_name);
        print!("Populating file '{}'...\n\n", file_path.display());
        $code
        // Write all the types we've collected into the file.
        write(
            file_path,
            $buffer_name.as_str(),
        )?;
        print!("Done!\n\n");
    };
}

#[allow(unused_macros)]
macro_rules! add_type_to_buffer {
    ($type: ty, $buf: ident, $inline_comment: expr) => {
        print!("Exporting {}... ", stringify!($type));
        let result = <$type as TS>::export_to_string();
        match result {
            Ok(out) => {
                let out_trimmed_l = out.replace(TS_RS_PREAMBLE_STR, "");
                let out_trimmed = out_trimmed_l.replace("\n", "");
                $buf.push_str(out_trimmed.as_str());
                if !$inline_comment.is_empty() {
                    $buf.push_str(" // ");
                    $buf.push_str($inline_comment);
                }
                $buf.push_str("\n");
                print!("done.\n");
            }
            Err(err) => {
                print!("Error: {}\n", err);
            }
        }
    };

    ($type: ty, $buf: ident) => {
        add_type_to_buffer!($type, $buf, "");
    };
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Accept a path to export files to (files will be overwritten)
    // or default to the current working directory.
    let path_str = args().skip(1).take(1).next().unwrap_or(".".to_string());
    let path = PathBuf::from(path_str);

    print!(
        "Outputting TypeScript types to '{}' folder...\n\n",
        path.display()
    );

    fill_and_save_buffer!(buffer, path, "types.ts", {
        // TODO: Fill in the code that exports types.
        // Recommend creating a new function for each library, as below.
        buffer.push_str(output_types_for_x().as_str());
    });

    Ok(())
}

fn output_types_for_x() -> String {
    let mut buffer = String::new();
    print!("** x types\n\n");
    // Add lines that use add_type_to_buffer for each type you want to output.
    print!("Done.\n----------------\n\n");

    buffer
}
