use holo_hash::export_ts::*;
use holo_hash::*;
use std::env::args;
use std::fs::write;
use std::path::PathBuf;
use ts_rs::TS;

const TS_RS_PREAMBLE_STR: &'static str = "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n";
const CUSTOM_PREAMBLE_STR: &'static str = "// This file was generated by [`export_ts` from the Holochain project](https://github.com/holochain/holochain/tree/main/crates/export_ts). Do not edit this file manually.\n\n";

macro_rules! fill_and_save_buffer {
    ($buffer_name: ident, $path: expr, $file_name: expr, $code: block) => {
        let mut $buffer_name = String::new();
        $buffer_name.push_str(CUSTOM_PREAMBLE_STR);
        let file_path = $path.join($file_name);
        print!("Populating file '{}'...\n\n", file_path.display());
        $code
        // Write all the types we've collected into the file.
        write(
            file_path,
            $buffer_name.as_str(),
        )?;
        print!("Done!\n\n");
    };
}

macro_rules! add_type_to_buffer {
    ($type: ty, $buf: ident, $inline_comment: expr) => {
        print!("Exporting {}... ", stringify!($type));
        let out = <$type as TS>::export_to_string()?;
        let out_trimmed_l = out.strip_prefix(TS_RS_PREAMBLE_STR).unwrap();
        let out_trimmed = out_trimmed_l.trim();
        $buf.push_str(out_trimmed);
        if !$inline_comment.is_empty() {
            $buf.push_str(" // ");
            $buf.push_str($inline_comment);
        }
        $buf.push_str("\n");
        print!("done.\n");
    };

    ($type: ty, $buf: ident) => {
        add_type_to_buffer!($type, $buf, "");
    };
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Accept a path to export files to (files will be overwritten)
    // or default to the current working directory.
    let path_str = args().nth(1).unwrap_or(".".to_string());
    let path = PathBuf::from(path_str);

    print!(
        "Outputting TypeScript types to '{}' folder...\n\n",
        path.display()
    );

    fill_and_save_buffer!(buffer, path, "types.ts", {
        // Fill in the code that exports types.
        // Recommend creating a new function for each library, as below.
        buffer.push_str(output_holo_hash_types()?.as_str());
    });

    Ok(())
}

fn output_holo_hash_types() -> Result<String, Box<(dyn std::error::Error + 'static)>> {
    let mut buffer = String::new();
    print!("** holo_hash types\n\n");
    buffer.push_str("/** Raw hash types */\n\n");
    buffer.push_str("/**
 * Hash types
 *
 * All HoloHashes are 39 bytes: a 3-byte multihash prefix, followed by a
 * 32-byte hash, and finally a 4-byte location.
 */\n\n");
    add_type_to_buffer!(BaseHoloHash, buffer);
    add_type_to_buffer!(AgentPubKey, buffer);
    add_type_to_buffer!(DnaHash, buffer);
    add_type_to_buffer!(WasmHash, buffer);
    add_type_to_buffer!(EntryHash, buffer);
    add_type_to_buffer!(ActionHash, buffer);
    add_type_to_buffer!(AnyDhtHash, buffer);
    add_type_to_buffer!(AnyLinkableHash, buffer);
    add_type_to_buffer!(ExternalHash, buffer);
    buffer.push_str("\n/**
 * Base64 hash types
 *
 * Base64-encoded versions of all the HoloHashes.
 */\n\n");
    add_type_to_buffer!(BaseHoloHashB64, buffer);
    add_type_to_buffer!(AgentPubKeyB64, buffer);
    add_type_to_buffer!(DnaHashB64, buffer);
    add_type_to_buffer!(WasmHashB64, buffer);
    add_type_to_buffer!(EntryHashB64, buffer);
    add_type_to_buffer!(ActionHashB64, buffer);
    add_type_to_buffer!(AnyDhtHashB64, buffer);
    add_type_to_buffer!(AnyLinkableHashB64, buffer);
    add_type_to_buffer!(ExternalHashB64, buffer);
    print!("Done.\n----------------\n\n");

    Ok(buffer)
}
