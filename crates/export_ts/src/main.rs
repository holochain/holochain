use std::env::args;
use std::fs::write;
use std::path::PathBuf;
use ts_rs::TS;

const TS_RS_PREAMBLE_STR: &'static str = "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n";
const CUSTOM_PREAMBLE_STR: &'static str = "// This file was generated by [`export_ts` from the Holochain project](https://github.com/holochain/holochain/tree/main/crates/export_ts). Do not edit this file manually.\n\n";

macro_rules! fill_and_save_buffer {
    ($buffer_name: ident, $path: expr, $file_name: expr, $code: block) => {
        let mut $buffer_name = String::new();
        $buffer_name.push_str(CUSTOM_PREAMBLE_STR);
        let file_path = $path.join($file_name);
        print!("Populating file '{}'...\n\n", file_path.display());
        $code
        // Write all the types we've collected into the file.
        write(
            file_path,
            $buffer_name.as_str(),
        )?;
        print!("Done!\n\n");
    };
}

macro_rules! add_type_to_buffer {
    ($type: ty, $buf: ident, $inline_comment: expr) => {
        print!("Exporting {}... ", stringify!($type));
        let result = <$type as TS>::export_to_string();
        match result {
            Ok(out) => {
                let out_trimmed_l = out.replace(TS_RS_PREAMBLE_STR, "");
                let out_trimmed = out_trimmed_l.replace("\n", "");
                $buf.push_str(out_trimmed.as_str());
                if !$inline_comment.is_empty() {
                    $buf.push_str(" // ");
                    $buf.push_str($inline_comment);
                }
                $buf.push_str("\n");
                print!("done.\n");
            }
            Err(err) => {
                print!("Error: {}\n", err);
            }
        }
    };

    ($type: ty, $buf: ident) => {
        add_type_to_buffer!($type, $buf, "");
    };
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Accept a path to export files to (files will be overwritten)
    // or default to the current working directory.
    let path_str = args().skip(1).take(1).next().unwrap_or(".".to_string());
    let path = PathBuf::from(path_str);

    print!(
        "Outputting TypeScript types to '{}' folder...\n\n",
        path.display()
    );

    fill_and_save_buffer!(buffer, path, "types.ts", {
        // TODO: Fill in the code that exports types.
        // Recommend creating a new function for each library, as below.
        types_file_buffer.push_str(output_holo_hash_types().as_str());
    });

    Ok(())
}

fn output_holo_hash_types() -> String {
    let mut buffer = String::new();
    print!("** holo_hash types\n\n");
    buffer.push_str("/** Raw hash types */\n\n");
    add_type_to_buffer!(BaseHoloHash, buffer, "length 39");
    add_type_to_buffer!(AgentPubKey, buffer);
    add_type_to_buffer!(DnaHash, buffer);
    add_type_to_buffer!(WasmHash, buffer);
    add_type_to_buffer!(EntryHash, buffer);
    add_type_to_buffer!(ActionHash, buffer);
    add_type_to_buffer!(AnyDhtHash, buffer);
    add_type_to_buffer!(AnyLinkableHash, buffer);
    add_type_to_buffer!(ExternalHash, buffer);
    buffer.push_str("\n/** Base64 hash types */\n\n");
    add_type_to_buffer!(BaseHoloHashB64, buffer);
    add_type_to_buffer!(AgentPubKeyB64, buffer);
    add_type_to_buffer!(DnaHashB64, buffer);
    add_type_to_buffer!(WasmHashB64, buffer);
    add_type_to_buffer!(EntryHashB64, buffer);
    add_type_to_buffer!(ActionHashB64, buffer);
    add_type_to_buffer!(AnyDhtHashB64, buffer);
    add_type_to_buffer!(AnyLinkableHashB64, buffer);
    add_type_to_buffer!(ExternalHashB64, buffer);
    print!("Done.\n----------------\n\n");

    buffer
}
