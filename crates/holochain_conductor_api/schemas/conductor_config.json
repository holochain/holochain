{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ConductorConfig",
  "description": "All the config information for the conductor",
  "type": "object",
  "properties": {
    "admin_interfaces": {
      "description": "Setup admin interfaces to control this conductor through a websocket connection.",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/definitions/AdminInterfaceConfig"
      }
    },
    "danger_generate_throwaway_device_seed": {
      "description": "If set, and if there is no seed in lair at the tag specified in `device_seed_lair_tag`, the conductor will create a random seed and store it in lair at the specified tag. This should only be used for test or throwaway environments, because this device seed can never be regenerated, which defeats the purpose of having a device seed in the first place.\n\nIf `device_seed_lair_tag` is not set, this setting has no effect.",
      "default": false,
      "type": "boolean"
    },
    "data_root_path": {
      "description": "The path to the data root for this conductor; This can be `None` while building up the config programatically but MUST be set by the time the config is used to build a conductor. The database and compiled wasm directories are derived from this path.",
      "anyOf": [
        {
          "$ref": "#/definitions/DataRootPath"
        },
        {
          "type": "null"
        }
      ]
    },
    "db_sync_strategy": {
      "description": "Override the default database synchronous strategy.\n\nSee [sqlite documentation] for information about database sync levels. See [`DbSyncStrategy`] for details. This is best left at its default value unless you know what you are doing.\n\n[sqlite documentation]: https://www.sqlite.org/pragma.html#pragma_synchronous",
      "default": "Resilient",
      "allOf": [
        {
          "$ref": "#/definitions/DbSyncStrategy"
        }
      ]
    },
    "device_seed_lair_tag": {
      "description": "The lair tag used to refer to the \"device seed\" which was used to generate the AgentPubKey for the DPKI cell.\n\nThis must not be changed once the conductor has been started for the first time.",
      "type": [
        "string",
        "null"
      ]
    },
    "dpki": {
      "description": "DPKI config for this conductor. This setting must not change once the conductor has been started for the first time.\n\nIf `dna_path` is present, the DNA file at this path will be used to install the DPKI service upon first conductor startup. If not present, the Deepkey DNA specified by the `holochain_deepkey_dna` crate and built into Holochain, will be used instead.",
      "default": {
        "dna_path": null,
        "network_seed": "",
        "allow_throwaway_random_dpki_agent_key": false,
        "no_dpki": true
      },
      "allOf": [
        {
          "$ref": "#/definitions/DpkiConfig"
        }
      ]
    },
    "keystore": {
      "description": "Define how Holochain conductor will connect to a keystore.",
      "default": {
        "type": "lair_server_in_proc"
      },
      "allOf": [
        {
          "$ref": "#/definitions/KeystoreConfig"
        }
      ]
    },
    "network": {
      "description": "Optional config for the network module.",
      "default": {
        "transport_pool": [
          {
            "type": "mem"
          }
        ],
        "bootstrap_service": null,
        "tuning_params": {
          "gossip_strategy": "sharded-gossip",
          "gossip_loop_iteration_delay_ms": "1000",
          "gossip_outbound_target_mbps": "100",
          "gossip_inbound_target_mbps": "100",
          "gossip_historic_outbound_target_mbps": "100",
          "gossip_historic_inbound_target_mbps": "100",
          "gossip_burst_ratio": "100",
          "gossip_peer_on_success_next_gossip_delay_ms": "60000",
          "gossip_peer_on_error_next_gossip_delay_ms": "300000",
          "gossip_agent_info_update_interval_ms": "300000",
          "gossip_round_timeout_ms": "60000",
          "gossip_redundancy_target": "100",
          "gossip_max_batch_size": "1000000",
          "gossip_arc_clamping": "full",
          "default_rpc_single_timeout_ms": "60000",
          "default_rpc_multi_remote_agent_count": "3",
          "default_rpc_multi_remote_request_grace_ms": "3000",
          "agent_info_expires_after_ms": "1200000",
          "tls_in_mem_session_storage": "512",
          "proxy_keepalive_ms": "120000",
          "proxy_to_expire_ms": "300000",
          "concurrent_limit_per_thread": "4096",
          "tx5_implicit_timeout_ms": "60000",
          "tx5_connection_count_max": "4096",
          "tx5_send_buffer_bytes_max": "65536",
          "tx5_recv_buffer_bytes_max": "65536",
          "tx5_incoming_message_bytes_max": "536870912",
          "tx5_message_size_max": "16777216",
          "tx5_internal_event_channel_size": "1024",
          "tx5_timeout_s": "60",
          "tx5_backoff_start_s": "5",
          "tx5_backoff_max_s": "60",
          "tx5_ban_time_s": "10",
          "tx5_min_ephemeral_udp_port": "1",
          "tx5_max_ephemeral_udp_port": "65535",
          "tx5_backend_tracing_enabled": "false",
          "tx5_backend_module": "go_pion",
          "tx5_backend_module_config": "{}",
          "danger_tls_keylog": "no_keylog",
          "danger_gossip_recent_threshold_secs": "900",
          "disable_publish": "false",
          "disable_recent_gossip": "false",
          "disable_historical_gossip": "false",
          "bootstrap_check_delay_backoff_multiplier": "2",
          "bootstrap_max_delay_s": "300"
        },
        "tracing_scope": null
      },
      "allOf": [
        {
          "$ref": "#/definitions/KitsuneP2pConfig"
        }
      ]
    },
    "tracing_override": {
      "description": "Override the environment specified tracing config.",
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "tuning_params": {
      "description": "Tuning parameters to adjust the behaviour of the conductor.",
      "default": null,
      "anyOf": [
        {
          "$ref": "#/definitions/ConductorTuningParams"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "definitions": {
    "AdminInterfaceConfig": {
      "description": "Information neeeded to spawn an admin interface",
      "type": "object",
      "required": [
        "driver"
      ],
      "properties": {
        "driver": {
          "description": "By what means the interface will be exposed. Currently the only option is a local websocket running on a configurable port.",
          "allOf": [
            {
              "$ref": "#/definitions/InterfaceDriver"
            }
          ]
        }
      }
    },
    "AllowedOrigins": {
      "description": "Access control for controlling WebSocket connections from browsers. Anywhere other than a browser can set the `Origin` header to any value, so this is only relevant for browser connections.\n\nSee [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) for more information.",
      "oneOf": [
        {
          "description": "Allow access from any origin.",
          "type": "string",
          "enum": [
            "Any"
          ]
        },
        {
          "description": "Allow access from a specific origin.",
          "type": "object",
          "required": [
            "Origins"
          ],
          "properties": {
            "Origins": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "uniqueItems": true
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ConductorTuningParams": {
      "description": "Tuning parameters to adjust the behaviour of the conductor.",
      "type": "object",
      "properties": {
        "countersigning_resolution_retry_delay": {
          "description": "The delay between retries attempts at resolving failed countersigning sessions.\n\nThis is potentially a very heavy operation because it has to gather information from the network, so it is recommended not to set this too low.\n\nDefault: 5 minutes",
          "anyOf": [
            {
              "$ref": "#/definitions/Duration"
            },
            {
              "type": "null"
            }
          ]
        },
        "countersigning_resolution_retry_limit": {
          "description": "The maximum number of times that Holochain should attempt to resolve a failed countersigning session.\n\nNote that this *only* applies to sessions that fail through a timeout. Sessions that fail because of a conductor crash or otherwise will not be limited by this value. This is a safety measure to make it less likely that timeout leads to a wrong decision because of a temporary network issue.\n\nHolochain will always try once, whatever value you set. The possible values for this setting are: - `None`: Not set, then Holochain will just make a single attempt and then consider the session failed if it can't make a decision. - `Some(0)`: Holochain will treat this the same as a session that failed after a crash. It will retry until it can make a decision or until the user forces a decision. - `Some(n)`, n > 0: Holochain will retry `n` times, including the required first attempt. If it can't make a decision after `n` retries, it will consider the session failed.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 0.0
        },
        "min_publish_interval": {
          "description": "Only publish a DhtOp once during this interval. This allows for triggering the publish workflow frequently without flooding the network with spurious publishes.\n\nDefault: 5 minutes",
          "anyOf": [
            {
              "$ref": "#/definitions/Duration"
            },
            {
              "type": "null"
            }
          ]
        },
        "sys_validation_retry_delay": {
          "description": "The delay between retries of sys validation when there are missing dependencies waiting to be found on the DHT.\n\nDefault: 10 seconds",
          "anyOf": [
            {
              "$ref": "#/definitions/Duration"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "DataRootPath": {
      "description": "Newtype to make sure we never accidentaly use or not use the data path. Intentionally has no default value.",
      "type": "string"
    },
    "DbSyncStrategy": {
      "description": "The strategy for database file system synchronization. Some databases like the cache can be safely rebuilt if corruption occurs due to using the faster [`DbSyncLevel::Off`].",
      "oneOf": [
        {
          "description": "Allows databases that can be wiped and rebuilt to use the faster [`DbSyncLevel::Off`]. This is the default.",
          "type": "string",
          "enum": [
            "Fast"
          ]
        },
        {
          "description": "Makes all databases use at least [`DbSyncLevel::Normal`]. This is probably not needed unless you have an SSD and would prefer to lower the chances of databases needing to be rebuilt.",
          "type": "string",
          "enum": [
            "Resilient"
          ]
        }
      ]
    },
    "DpkiConfig": {
      "description": "Configure DPKI properties.\n\nNote that the Deepkey DNA path and the network seed settings determine network compatibility. They have to match for all conductors on a network, for them to be able to communicate.\n\nAlso see `NetworkCompatParams` in the `holochain_p2p` crate.",
      "type": "object",
      "required": [
        "network_seed"
      ],
      "properties": {
        "allow_throwaway_random_dpki_agent_key": {
          "description": "Allow the DPKI agent key to be generated randomly in the absence of a [`crate::config::conductor::ConductorConfig::device_seed_lair_tag`] setting. This is useful in test environments where the device seed is not set and key regeneration is not needed. For any real use of Holochain, do not set this to true!",
          "default": false,
          "type": "boolean"
        },
        "dna_path": {
          "description": "Path to a DNA which implements the DPKI service, i.e. Deepkey. Defaults to the built-in Deepkey DNA from the holochain_deepkey_dna crate.",
          "type": [
            "string",
            "null"
          ]
        },
        "network_seed": {
          "description": "DPKI is always installed with a network seed. Only conductors using the exact same DPKI service can communicate with each other. This means that this network seed must match across all conductors in a network.",
          "type": "string"
        },
        "no_dpki": {
          "description": "For testing only, we can turn off DPKI if needed.",
          "default": false,
          "type": "boolean"
        }
      }
    },
    "Duration": {
      "type": "object",
      "required": [
        "nanos",
        "secs"
      ],
      "properties": {
        "nanos": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "secs": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "InterfaceDriver": {
      "description": "Configuration for interfaces, specifying the means by which an interface should be opened.\n\n**NB**: This struct is used in both [`ConductorConfig`] and [`ConductorState`], so any change to the serialization strategy is a breaking change.\n\n[`ConductorConfig`]: crate::conductor::ConductorConfig [`ConductorState`]: https://docs.rs/holochain/latest/holochain/conductor/state/struct.ConductorState.html",
      "oneOf": [
        {
          "description": "An interface implemented via websockets",
          "type": "object",
          "required": [
            "allowed_origins",
            "port",
            "type"
          ],
          "properties": {
            "allowed_origins": {
              "description": "Allowed origins for this interface.\n\nThis should be one of: - A comma separated list of origins - `http://localhost:3000,http://localhost:3001`, - A single origin - `http://localhost:3000`, - Any origin - `*`\n\nConnections from any origin which is not permitted by this config will be rejected.",
              "allOf": [
                {
                  "$ref": "#/definitions/AllowedOrigins"
                }
              ]
            },
            "port": {
              "description": "The port on which to establish the WebsocketListener",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "websocket"
              ]
            }
          }
        }
      ]
    },
    "KeystoreConfig": {
      "description": "Define how Holochain conductor will connect to a keystore, and how to collect the passphrase needed to unlock the keystore.",
      "oneOf": [
        {
          "description": "Enabling this will use a test keystore instead of lair. This generates publicly accessible private keys. DO NOT USE THIS IN PRODUCTION!",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "danger_test_keystore"
              ]
            }
          }
        },
        {
          "description": "Connect to an external lair-keystore process. This keystore type requires a secure passphrase specified to the cli binary entrypoint for this Holochain conductor process.",
          "type": "object",
          "required": [
            "connection_url",
            "type"
          ],
          "properties": {
            "connection_url": {
              "description": "The \"connectionUrl\" as defined in your \"lair-keystore-config.yaml\". This value is also accessible by running `lair-keystore url`.",
              "type": "string",
              "format": "uri"
            },
            "type": {
              "type": "string",
              "enum": [
                "lair_server"
              ]
            }
          }
        },
        {
          "description": "Run a lair-keystore server in-process. It will require exclusive access to the root directory (no other conductors can share this lair). This keystore type requires a secure passphrase specified to the cli binary entrypoint for this Holochain conductor process.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "lair_root": {
              "description": "The \"lair_root\" path, i.e. the directory containing the \"lair-keystore-config.yaml\" file. If not specified, will default to the ConductorConfig `[environment_path]/ks`.",
              "anyOf": [
                {
                  "$ref": "#/definitions/KeystorePath"
                },
                {
                  "type": "null"
                }
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "lair_server_in_proc"
              ]
            }
          }
        }
      ]
    },
    "KeystorePath": {
      "description": "Newtype to make sure we never accidentaly use or not use the keystore path. Intentionally has no default value.",
      "type": "string"
    },
    "KitsuneP2pConfig": {
      "description": "Configure the kitsune actor.",
      "type": "object",
      "required": [
        "bootstrap_service",
        "transport_pool"
      ],
      "properties": {
        "bootstrap_service": {
          "description": "The service used for peers to discover each before they are peers.",
          "type": "string",
          "format": "uri"
        },
        "tracing_scope": {
          "description": "All tracing logs from kitsune tasks will be instrumented to contain this string, so that logs from multiple instances in the same process can be disambiguated.",
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "transport_pool": {
          "description": "List of sub-transports to be included in this pool",
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransportConfig"
          }
        },
        "tuning_params": {
          "description": "Network tuning parameters. These are managed loosely, as they are subject to change. If you specify a tuning parameter that no longer exists, or a value that does not parse, a warning will be printed in the tracing log.",
          "default": {
            "gossip_strategy": "sharded-gossip",
            "gossip_loop_iteration_delay_ms": "1000",
            "gossip_outbound_target_mbps": "100",
            "gossip_inbound_target_mbps": "100",
            "gossip_historic_outbound_target_mbps": "100",
            "gossip_historic_inbound_target_mbps": "100",
            "gossip_burst_ratio": "100",
            "gossip_peer_on_success_next_gossip_delay_ms": "60000",
            "gossip_peer_on_error_next_gossip_delay_ms": "300000",
            "gossip_agent_info_update_interval_ms": "300000",
            "gossip_round_timeout_ms": "60000",
            "gossip_redundancy_target": "100",
            "gossip_max_batch_size": "1000000",
            "gossip_arc_clamping": "full",
            "default_rpc_single_timeout_ms": "60000",
            "default_rpc_multi_remote_agent_count": "3",
            "default_rpc_multi_remote_request_grace_ms": "3000",
            "agent_info_expires_after_ms": "1200000",
            "tls_in_mem_session_storage": "512",
            "proxy_keepalive_ms": "120000",
            "proxy_to_expire_ms": "300000",
            "concurrent_limit_per_thread": "4096",
            "tx5_implicit_timeout_ms": "60000",
            "tx5_connection_count_max": "4096",
            "tx5_send_buffer_bytes_max": "65536",
            "tx5_recv_buffer_bytes_max": "65536",
            "tx5_incoming_message_bytes_max": "536870912",
            "tx5_message_size_max": "16777216",
            "tx5_internal_event_channel_size": "1024",
            "tx5_timeout_s": "60",
            "tx5_backoff_start_s": "5",
            "tx5_backoff_max_s": "60",
            "tx5_ban_time_s": "10",
            "tx5_min_ephemeral_udp_port": "1",
            "tx5_max_ephemeral_udp_port": "65535",
            "tx5_backend_tracing_enabled": "false",
            "tx5_backend_module": "go_pion",
            "tx5_backend_module_config": "{}",
            "danger_tls_keylog": "no_keylog",
            "danger_gossip_recent_threshold_secs": "900",
            "disable_publish": "false",
            "disable_recent_gossip": "false",
            "disable_historical_gossip": "false",
            "bootstrap_check_delay_backoff_multiplier": "2",
            "bootstrap_max_delay_s": "300"
          },
          "allOf": [
            {
              "$ref": "#/definitions/KitsuneP2pTuningParams"
            }
          ]
        }
      }
    },
    "KitsuneP2pTuningParams": {
      "description": "Network tuning parameters. This is serialized carefully so all the values can be represented as strings in YAML - and we will be able to proceed with a printed warning for tuning params that are removed, but still specified in configs.",
      "type": "object",
      "required": [
        "agent_info_expires_after_ms",
        "bootstrap_check_delay_backoff_multiplier",
        "bootstrap_max_delay_s",
        "concurrent_limit_per_thread",
        "danger_gossip_recent_threshold_secs",
        "danger_tls_keylog",
        "default_rpc_multi_remote_agent_count",
        "default_rpc_multi_remote_request_grace_ms",
        "default_rpc_single_timeout_ms",
        "disable_historical_gossip",
        "disable_publish",
        "disable_recent_gossip",
        "gossip_agent_info_update_interval_ms",
        "gossip_arc_clamping",
        "gossip_burst_ratio",
        "gossip_historic_inbound_target_mbps",
        "gossip_historic_outbound_target_mbps",
        "gossip_inbound_target_mbps",
        "gossip_loop_iteration_delay_ms",
        "gossip_max_batch_size",
        "gossip_outbound_target_mbps",
        "gossip_peer_on_error_next_gossip_delay_ms",
        "gossip_peer_on_success_next_gossip_delay_ms",
        "gossip_redundancy_target",
        "gossip_round_timeout_ms",
        "gossip_strategy",
        "proxy_keepalive_ms",
        "proxy_to_expire_ms",
        "tls_in_mem_session_storage",
        "tx5_backend_module",
        "tx5_backend_module_config",
        "tx5_backend_tracing_enabled",
        "tx5_backoff_max_s",
        "tx5_backoff_start_s",
        "tx5_ban_time_s",
        "tx5_connection_count_max",
        "tx5_implicit_timeout_ms",
        "tx5_incoming_message_bytes_max",
        "tx5_internal_event_channel_size",
        "tx5_max_ephemeral_udp_port",
        "tx5_message_size_max",
        "tx5_min_ephemeral_udp_port",
        "tx5_recv_buffer_bytes_max",
        "tx5_send_buffer_bytes_max",
        "tx5_timeout_s"
      ],
      "properties": {
        "agent_info_expires_after_ms": {
          "description": "Default agent expires after milliseconds. [Default: 20 minutes]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "bootstrap_check_delay_backoff_multiplier": {
          "description": "Control the backoff multiplier for the time delay between checking in with the bootstrap server. The default value of `2` causes the delay to grow quickly up to the max time of 1 hour. For testing consider using `1` to prevent the delay from growing.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "bootstrap_max_delay_s": {
          "description": "Set the bootstrap fetch maximum backoff time. The default value is 60 * 5 s = five minutes. The minimum value is 60 s = one minute.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "concurrent_limit_per_thread": {
          "description": "Mainly used as the for_each_concurrent limit, this restricts the number of active polled futures on a single thread. [Default: 4096]",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "danger_gossip_recent_threshold_secs": {
          "description": "Set the cutoff time when gossip switches over from recent to historical gossip.\n\nThis is dangerous to change, because gossip may not be possible with nodes using a different setting for this threshold. Do not change this except in testing environments. [Default: 15 minutes]",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "danger_tls_keylog": {
          "description": "if you would like to be able to use an external tool to debug the QUIC messages sent and received by kitsune you'll need the decryption keys. The default of `\"no_keylog\"` is secure and will not write any keys Setting this to `\"env_keylog\"` will write to a keylog specified by the `SSLKEYLOGFILE` environment variable, or do nothing if it is not set, or is not writable.",
          "type": "string"
        },
        "default_rpc_multi_remote_agent_count": {
          "description": "Default agent count for rpc multi. [Default: 3]",
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        },
        "default_rpc_multi_remote_request_grace_ms": {
          "description": "Default remote request grace ms. [Default: 3s] If we already have results from other sources, but made any additional outgoing remote requests, we'll wait at least this long for additional responses.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "default_rpc_single_timeout_ms": {
          "description": "Default timeout for rpc single. [Default: 60s]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "disable_historical_gossip": {
          "description": "Disable historical gossip. Useful for testing Recent gossip in isolation.",
          "type": "boolean"
        },
        "disable_publish": {
          "description": "Don't publish ops, only rely on gossip. Useful for testing the efficacy of gossip.",
          "type": "boolean"
        },
        "disable_recent_gossip": {
          "description": "Disable recent gossip. Useful for testing Historical gossip in isolation. Note that this also disables agent gossip!",
          "type": "boolean"
        },
        "gossip_agent_info_update_interval_ms": {
          "description": "How often should we update and publish our agent info? [Default: 5 minutes]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "gossip_arc_clamping": {
          "type": "string"
        },
        "gossip_burst_ratio": {
          "description": "The gossip loop accomodates this amount of excess capacity before enacting the target rate limit, expressed as a ratio of the target rate limit. For instance, if the historic outbound target is 10mbps, a burst ratio of 50 will allow an extra 500mb of outbound traffic before the target rate limiting kicks in (and this extra capacity will take 50 seconds to \"refill\"). [Default: 100.0]",
          "type": "number",
          "format": "double"
        },
        "gossip_historic_inbound_target_mbps": {
          "description": "The gossip loop will attempt to rate-limit inbound traffic for the historic loop (if there is one) to this count megabits per second. [Default: 100.0]",
          "type": "number",
          "format": "double"
        },
        "gossip_historic_outbound_target_mbps": {
          "description": "The gossip loop will attempt to rate-limit outbound traffic for the historic loop (if there is one) to this count megabits per second. [Default: 100.0]",
          "type": "number",
          "format": "double"
        },
        "gossip_inbound_target_mbps": {
          "description": "The gossip loop will attempt to rate-limit input to this count megabits per second. [Default: 100.0]",
          "type": "number",
          "format": "double"
        },
        "gossip_loop_iteration_delay_ms": {
          "description": "Delay between gossip loop iteration. [Default: 1s]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "gossip_max_batch_size": {
          "description": "The max number of bytes of data to send in a single message.\n\nThis setting was more relevant when entire Ops were being gossiped, but now that only hashes are gossiped, it would take a lot of hashes to reach this limit (1MB = approx 277k hashes).\n\nPayloads larger than this are split into multiple batches when possible.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "gossip_outbound_target_mbps": {
          "description": "The gossip loop will attempt to rate-limit output to this count megabits per second. [Default: 100.0]",
          "type": "number",
          "format": "double"
        },
        "gossip_peer_on_error_next_gossip_delay_ms": {
          "description": "How long should we hold off talking to a peer we've previously gotten errors speaking to. [Default: 5 minute]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "gossip_peer_on_success_next_gossip_delay_ms": {
          "description": "How long should we hold off talking to a peer we've previously spoken successfully to. [Default: 1 minute]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "gossip_redundancy_target": {
          "description": "The target redundancy is the number of peers we expect to hold any given Op.",
          "type": "number",
          "format": "double"
        },
        "gossip_round_timeout_ms": {
          "description": "The timeout for a gossip round if there is no contact. [Default: 1 minute]",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "gossip_strategy": {
          "description": "Gossip strategy to use. [Default: \"sharded-gossip\"]",
          "type": "string"
        },
        "proxy_keepalive_ms": {
          "description": "How often should NAT nodes refresh their proxy contract? [Default: 2 minutes]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "proxy_to_expire_ms": {
          "description": "How often should proxy nodes prune their ProxyTo list? Note - to function this should be > proxy_keepalive_ms. [Default: 5 minutes]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tls_in_mem_session_storage": {
          "description": "Tls in-memory session storage capacity. [Default: 512]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_backend_module": {
          "description": "The backend tx5 module to be used. This defaults to \"go_pion\" which is also the default if unspecified or invalid. Options currently inclued: - \"go_pion\" - based off the golang pion webrtc library - \"mem\" - a stub memory backend for performance/validation testing",
          "type": "string"
        },
        "tx5_backend_module_config": {
          "description": "The additional tx5 backend module config. This should be a json object with backend module specific configuration as specified by tx5. Defaults to an empty object (\"{}\").",
          "type": "string"
        },
        "tx5_backend_tracing_enabled": {
          "description": "Set this to `true` to enable verbose webrtc backend tracing.",
          "type": "boolean"
        },
        "tx5_backoff_max_s": {
          "description": "Max backoff duration for retries. [Default: 60]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_backoff_start_s": {
          "description": "Starting backoff duration for retries. [Default: 60]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_ban_time_s": {
          "description": "Tx5 ban time in seconds.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_connection_count_max": {
          "description": "Maximum count of open connections. [Default: 4096]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_implicit_timeout_ms": {
          "description": "tx5 timeout used for passive background operations like reads / responds. [Default: 60 seconds]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_incoming_message_bytes_max": {
          "description": "Maximum receive message reconstruction bytes in memory (accross entire endpoint). [Default: 512 MiB]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_internal_event_channel_size": {
          "description": "Internal event channel size. [Default: 1024]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_max_ephemeral_udp_port": {
          "description": "Tx5 max ephemeral port",
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "tx5_message_size_max": {
          "description": "Maximum size of an individual message. [Default: 16 MiB]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_min_ephemeral_udp_port": {
          "description": "Tx5 min ephemeral port",
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "tx5_recv_buffer_bytes_max": {
          "description": "Max backend recv buffer bytes (per connection). [Default: 64 KiB]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_send_buffer_bytes_max": {
          "description": "Max backend send buffer bytes (per connection). [Default: 64 KiB]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx5_timeout_s": {
          "description": "Default timeout for network operations. [Default: 60]",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "TransportConfig": {
      "description": "Configure the network bindings for underlying kitsune transports.",
      "oneOf": [
        {
          "description": "Configure to use Tx5 WebRTC for kitsune networking.",
          "type": "object",
          "required": [
            "signal_url",
            "type"
          ],
          "properties": {
            "signal_url": {
              "description": "The url of the signal server to connect to for addressability.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "webrtc"
              ]
            },
            "webrtc_config": {
              "description": "Webrtc peer connection config."
            }
          }
        },
        {
          "description": "A transport that uses the local memory transport protocol (this is mainly for testing)",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "mem"
              ]
            }
          }
        }
      ]
    }
  }
}